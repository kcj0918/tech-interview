# OS

**:Contents**
* lru 알고리즘(#LRU알고리즘이란)
* 프로세스와 스레드의 차이(Process vs Thread)
* 멀티 프로세스 대신 멀티 스레드를 사용하는 이유
* Thread-safe
* 동기화 객체의 종류
* 뮤텍스와 세마포어의 차이
* 스케줄러
* 동기와 비동기
* 프로세스 동기화
* 메모리 관리 전략
* 가상 메모리
* 캐시의 지역성
* 교착상태(데드락, Deadlock)의 개념과 조건
* 사용자 수준 스레드와 커널 수준 스레드
* 외부 단편화와 내부 단편화
* Context Switching
* Swapping

---

### LRU알고리즘이란  Least-Recently-Used

페이지 교체 알고리즘 중에 하나이다.
메모리에 빈 프레임이 없을 때 적재될 페이지를 위해 적재된 페이지 중 누군가는
자신이 차지한 프레임을 비워주어야 하는 교체 대상이 되어야 한다.
어떤 페이지를 선택하는 것이 최적의 기법이 인지 판단하는 다양한 기법들이 있고 페이지 교체 알고리즘이라고 한다.

LRU알고리즘은 `최근에 사용하지 않는 페이지를 가장 먼저 내려 보내는 알고리즘`이다.


`LRU알고리즘 예제`


![A](img/os_lru.png)

* 페이지 크기가 3이라고 가정하고 0 부터 4 까지의 숫자들이 참조되는 경우를 그린 LRU 알고리즘의 상태 변화과정을 나타낸 표
* 황색 표시는 페이지가 교체 되는 상황이고 연두색은 페이지에 데이터가 존재하여 갱신되는 경우

1).시간1-6까지는 최근에 사용하지 않는 페이지를 내보내고 페이지 교체한다.
2).시간7인 경우에는 cache hit => 3
3).시간8인 경우 최근에 사용하지 않는 참조값 4를 가진 2번째 페이지 교체
4).시간9에서 다시 cache hit => 3




### 프로세스와 스레드의 차이(Process vs Thread)
#### 프로세스
`프로세스의 구성`
![A](img/os_thread1.png)


* 프로세스 : 스레드 + 메모리공간(stack, code , data , heap)
* 실행중인 프로그램이다.
ex) spring boot application


[cpu 를!]
OS의 스케줄러애 의해 time slice만큼 실행

[memory 를!]
OS로 할당받은 메모리 공간 사용
code , data , heap , stack


`프로세스의 특징`
cpu는 가상메모리를 통해 Ram주소를 들어간다.

가상메모리는 일종의 프로세스를 가리키는 페이징 테이블이라고 한다.
프로세스간 메모리 공간격리


가상메모리는 프로세스간 주소공간을 논리적으로 차단한다.


![A](img/os_multiprocess.png)


`T1 ,T2 == task_struct`

task_struct는 커널의 중요한 객체이며 실행중인 프로그램인 프로세스는 리눅스에서는 테스크(task)와 동일한 의미로 사용된다.
프로세스는 파일 시스템에서 메모리로 로드한 코드, 데이터(프로그램)와 이를 커널에서 관리하기 위한 task_struct 구조체이다.


정리하자면 프로세스는 task_struct구조체를 통해 스레드라는 자원을 관리한다. 




`페이지테이블이란`




#### 스레드
* 프로세스를 만드는 것보다 비용이 저렴
* 스레드들간 HEAP 메모리 공간 공유
* 하나의 프로세스에 하나의 스레드가 있는 상황에서 신규 스레드가 추가된다면 신규 스레드가 사용할 stack 메모리 공간만
생성된다.



![A](img/os_newthread.png)



### 멀티 프로세스 대신 멀티 스레드를 사용하는 이유

[리눅스기준]
#### 스레드의 생성의 비용이 더 저렴하다.


#### context switch 비용

cpu와 LAM 영역 사이에 메모리 인풋 아웃 IO작업이 일어나는데
LAM 영역에 접근하는데 많이 시간이 걸린다.

스레드의 경우 HEAP 메모리 영역을 공유하므로 한 프로세스안에 다른 스레드들이 context switch이
일어나도 캐시에 같이 데이터가 있을 수 있기 때문에

캐싱 측면에서 스레드 모델 성능이 좋다.


멀티 프로세스 모델은 서로간 메모리를 공유 할 수 없기 때문에 
context switch시 캐시 레이어를 리셋해버린다.
그렇기 때문에 속도적으로 이슈가 생긴다.



![A](img/os_io_time.png)

![A](img/os_process-thread.png)

